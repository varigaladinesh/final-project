from fastapi import FastAPI, UploadFile, File, Form
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
import os, shutil

from fastapi.responses import FileResponse
from crypto.ecc import generate_ecc_shared_secret, recover_ecc_shared_secret
from crypto.aes import aes_encrypt, aes_decrypt
from crypto.sha import generate_sha256
from steganography.embed import embed_data, max_capacity
from steganography.extract import extract_data

# üîê Stego signature (ADVANCEMENT 4)
STEGO_SIGNATURE = b"SDI_ECC_AES_SHA_v1||"

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

UPLOAD_DIR = "uploads"
OUTPUT_DIR = "outputs"

os.makedirs(UPLOAD_DIR, exist_ok=True)
os.makedirs(OUTPUT_DIR, exist_ok=True)


@app.post("/encrypt")
async def encrypt_image(
    secret_message: str = Form(...),
    password: str = Form(...),
    image: UploadFile = File(...)
):
    # Save uploaded image
    img_path = os.path.join(UPLOAD_DIR, image.filename)
    with open(img_path, "wb") as f:
        shutil.copyfileobj(image.file, f)

    # Generate SHA
    sha = generate_sha256(secret_message)

    # ECC shared secret
    eph_pub, ecc_key = generate_ecc_shared_secret()

    # AES encryption
    plaintext = secret_message + "||" + sha
    ciphertext = aes_encrypt(plaintext, password, ecc_key)

    # üîê Payload with stego signature (ADVANCEMENT 4)
    payload = STEGO_SIGNATURE + eph_pub + b"||" + ciphertext

    # üìè Capacity validation (ADVANCEMENT 2)
    if len(payload) > max_capacity(img_path):
        return {
            "status": "Failed",
            "message": "Message too large for this image"
        }

    # Embed into image
    out_name = "secured_" + image.filename
    out_path = os.path.join(OUTPUT_DIR, out_name)
    embed_data(img_path, payload, out_path)

    return {
        "status": "Success",
        "sha256": sha,
        "download_url": f"https://secure-image-uiwh.onrender.com/download/{out_name}",
    }


@app.post("/decrypt")
async def decrypt_image(
    password: str = Form(...),
    image: UploadFile = File(...)
):
    # Save uploaded secured image
    img_path = os.path.join(UPLOAD_DIR, image.filename)
    with open(img_path, "wb") as f:
        shutil.copyfileobj(image.file, f)

    try:
        extracted = extract_data(img_path)

        # üîç Verify stego signature (ADVANCEMENT 4)
        if not extracted.startswith(STEGO_SIGNATURE):
            return {
                "status": "Invalid Image",
                "message": "Image not generated by this system"
            }

        extracted = extracted[len(STEGO_SIGNATURE):]

        # Split payload
        eph_pub, ciphertext = extracted.split(b"||", 1)

        # Recover ECC shared secret
        ecc_key = recover_ecc_shared_secret(eph_pub)

        # AES decrypt
        plaintext = aes_decrypt(ciphertext, password, ecc_key)

        message, sha = plaintext.split("||", 1)

        # Verify SHA
        if generate_sha256(message) != sha:
            return {"status": "Integrity Failed"}

        return {
            "status": "Integrity Verified",
            "message": message,
        }

    except Exception:
        return {
            "status": "Decryption Failed",
            "message": "Wrong password or invalid image",
        }




@app.get("/download/{filename}")
def download_file(filename: str):
    return FileResponse(os.path.join(OUTPUT_DIR, filename))